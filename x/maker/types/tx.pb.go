// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: blackfury/maker/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgMintBySwap represents a message to mint Black stablecoins by swapping.
type MsgMintBySwap struct {
	Sender       string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender" yaml:"sender"`
	To           string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to" yaml:"to"`
	BackingInMax types.Coin `protobuf:"bytes,3,opt,name=backing_in_max,json=backingInMax,proto3" json:"backing_in_max" yaml:"backing_in_max"`
	FuryInMax    types.Coin `protobuf:"bytes,4,opt,name=fury_in_max,json=furyInMax,proto3" json:"fury_in_max" yaml:"fury_in_max"`
	MintOutMin   types.Coin `protobuf:"bytes,5,opt,name=mint_out_min,json=mintOutMin,proto3" json:"mint_out_min" yaml:"mint_out_min"`
	FullBacking  bool       `protobuf:"varint,6,opt,name=full_backing,json=fullBacking,proto3" json:"full_backing" yaml:"full_backing"`
}

func (m *MsgMintBySwap) Reset()         { *m = MsgMintBySwap{} }
func (m *MsgMintBySwap) String() string { return proto.CompactTextString(m) }
func (*MsgMintBySwap) ProtoMessage()    {}
func (*MsgMintBySwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{0}
}
func (m *MsgMintBySwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintBySwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintBySwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintBySwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintBySwap.Merge(m, src)
}
func (m *MsgMintBySwap) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintBySwap) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintBySwap.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintBySwap proto.InternalMessageInfo

// MsgMintBySwapResponse defines the Msg/MintBySwap response type.
type MsgMintBySwapResponse struct {
	BackingIn types.Coin `protobuf:"bytes,1,opt,name=backing_in,json=backingIn,proto3" json:"backing_in" yaml:"backing_in"`
	FuryIn    types.Coin `protobuf:"bytes,2,opt,name=fury_in,json=furyIn,proto3" json:"fury_in" yaml:"fury_in"`
	MintOut   types.Coin `protobuf:"bytes,3,opt,name=mint_out,json=mintOut,proto3" json:"mint_out" yaml:"mint_out"`
	MintFee   types.Coin `protobuf:"bytes,4,opt,name=mint_fee,json=mintFee,proto3" json:"mint_fee" yaml:"mint_fee"`
}

func (m *MsgMintBySwapResponse) Reset()         { *m = MsgMintBySwapResponse{} }
func (m *MsgMintBySwapResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMintBySwapResponse) ProtoMessage()    {}
func (*MsgMintBySwapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{1}
}
func (m *MsgMintBySwapResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintBySwapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintBySwapResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintBySwapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintBySwapResponse.Merge(m, src)
}
func (m *MsgMintBySwapResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintBySwapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintBySwapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintBySwapResponse proto.InternalMessageInfo

func (m *MsgMintBySwapResponse) GetBackingIn() types.Coin {
	if m != nil {
		return m.BackingIn
	}
	return types.Coin{}
}

func (m *MsgMintBySwapResponse) GetFuryIn() types.Coin {
	if m != nil {
		return m.FuryIn
	}
	return types.Coin{}
}

func (m *MsgMintBySwapResponse) GetMintOut() types.Coin {
	if m != nil {
		return m.MintOut
	}
	return types.Coin{}
}

func (m *MsgMintBySwapResponse) GetMintFee() types.Coin {
	if m != nil {
		return m.MintFee
	}
	return types.Coin{}
}

// MsgBurnBySwap represents a message to burn Black stablecoins by swapping.
type MsgBurnBySwap struct {
	Sender        string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender" yaml:"sender"`
	To            string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to" yaml:"to"`
	BurnIn        types.Coin `protobuf:"bytes,3,opt,name=burn_in,json=burnIn,proto3" json:"burn_in" yaml:"burn_in"`
	BackingOutMin types.Coin `protobuf:"bytes,4,opt,name=backing_out_min,json=backingOutMin,proto3" json:"backing_out_min" yaml:"backing_out_min"`
	FuryOutMin    types.Coin `protobuf:"bytes,5,opt,name=fury_out_min,json=furyOutMin,proto3" json:"fury_out_min" yaml:"fury_out_min"`
}

func (m *MsgBurnBySwap) Reset()         { *m = MsgBurnBySwap{} }
func (m *MsgBurnBySwap) String() string { return proto.CompactTextString(m) }
func (*MsgBurnBySwap) ProtoMessage()    {}
func (*MsgBurnBySwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{2}
}
func (m *MsgBurnBySwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnBySwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnBySwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnBySwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnBySwap.Merge(m, src)
}
func (m *MsgBurnBySwap) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnBySwap) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnBySwap.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnBySwap proto.InternalMessageInfo

// MsgBurnBySwapResponse defines the Msg/BurnBySwap response type.
type MsgBurnBySwapResponse struct {
	BackingOut types.Coin `protobuf:"bytes,1,opt,name=backing_out,json=backingOut,proto3" json:"backing_out" yaml:"backing_out"`
	FuryOut    types.Coin `protobuf:"bytes,2,opt,name=fury_out,json=furyOut,proto3" json:"fury_out" yaml:"fury_out"`
	BurnFee    types.Coin `protobuf:"bytes,3,opt,name=burn_fee,json=burnFee,proto3" json:"burn_fee" yaml:"burn_fee"`
}

func (m *MsgBurnBySwapResponse) Reset()         { *m = MsgBurnBySwapResponse{} }
func (m *MsgBurnBySwapResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnBySwapResponse) ProtoMessage()    {}
func (*MsgBurnBySwapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{3}
}
func (m *MsgBurnBySwapResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnBySwapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnBySwapResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnBySwapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnBySwapResponse.Merge(m, src)
}
func (m *MsgBurnBySwapResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnBySwapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnBySwapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnBySwapResponse proto.InternalMessageInfo

func (m *MsgBurnBySwapResponse) GetBackingOut() types.Coin {
	if m != nil {
		return m.BackingOut
	}
	return types.Coin{}
}

func (m *MsgBurnBySwapResponse) GetFuryOut() types.Coin {
	if m != nil {
		return m.FuryOut
	}
	return types.Coin{}
}

func (m *MsgBurnBySwapResponse) GetBurnFee() types.Coin {
	if m != nil {
		return m.BurnFee
	}
	return types.Coin{}
}

// MsgBuyBacking represents a message to buy strong-backing assets.
type MsgBuyBacking struct {
	Sender        string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender" yaml:"sender"`
	To            string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to" yaml:"to"`
	FuryIn        types.Coin `protobuf:"bytes,3,opt,name=fury_in,json=furyIn,proto3" json:"fury_in" yaml:"fury_in"`
	BackingOutMin types.Coin `protobuf:"bytes,4,opt,name=backing_out_min,json=backingOutMin,proto3" json:"backing_out_min" yaml:"backing_out_min"`
}

func (m *MsgBuyBacking) Reset()         { *m = MsgBuyBacking{} }
func (m *MsgBuyBacking) String() string { return proto.CompactTextString(m) }
func (*MsgBuyBacking) ProtoMessage()    {}
func (*MsgBuyBacking) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{4}
}
func (m *MsgBuyBacking) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBuyBacking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBuyBacking.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBuyBacking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBuyBacking.Merge(m, src)
}
func (m *MsgBuyBacking) XXX_Size() int {
	return m.Size()
}
func (m *MsgBuyBacking) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBuyBacking.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBuyBacking proto.InternalMessageInfo

// MsgBuyBackingResponse defines the Msg/BuyBacking response type.
type MsgBuyBackingResponse struct {
	BackingOut types.Coin `protobuf:"bytes,1,opt,name=backing_out,json=backingOut,proto3" json:"backing_out" yaml:"backing_out"`
	BuybackFee types.Coin `protobuf:"bytes,2,opt,name=buyback_fee,json=buybackFee,proto3" json:"buyback_fee" yaml:"buyback_fee"`
}

func (m *MsgBuyBackingResponse) Reset()         { *m = MsgBuyBackingResponse{} }
func (m *MsgBuyBackingResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBuyBackingResponse) ProtoMessage()    {}
func (*MsgBuyBackingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{5}
}
func (m *MsgBuyBackingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBuyBackingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBuyBackingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBuyBackingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBuyBackingResponse.Merge(m, src)
}
func (m *MsgBuyBackingResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBuyBackingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBuyBackingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBuyBackingResponse proto.InternalMessageInfo

func (m *MsgBuyBackingResponse) GetBackingOut() types.Coin {
	if m != nil {
		return m.BackingOut
	}
	return types.Coin{}
}

func (m *MsgBuyBackingResponse) GetBuybackFee() types.Coin {
	if m != nil {
		return m.BuybackFee
	}
	return types.Coin{}
}

// MsgSellBacking represents a message to sell strong-backing
// assets.
type MsgSellBacking struct {
	Sender     string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender" yaml:"sender"`
	To         string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to" yaml:"to"`
	BackingIn  types.Coin `protobuf:"bytes,3,opt,name=backing_in,json=backingIn,proto3" json:"backing_in" yaml:"backing_in"`
	FuryOutMin types.Coin `protobuf:"bytes,4,opt,name=fury_out_min,json=furyOutMin,proto3" json:"fury_out_min" yaml:"fury_out_min"`
}

func (m *MsgSellBacking) Reset()         { *m = MsgSellBacking{} }
func (m *MsgSellBacking) String() string { return proto.CompactTextString(m) }
func (*MsgSellBacking) ProtoMessage()    {}
func (*MsgSellBacking) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{6}
}
func (m *MsgSellBacking) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSellBacking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSellBacking.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSellBacking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSellBacking.Merge(m, src)
}
func (m *MsgSellBacking) XXX_Size() int {
	return m.Size()
}
func (m *MsgSellBacking) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSellBacking.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSellBacking proto.InternalMessageInfo

// MsgSellBackingResponse defines the Msg/SellBacking response type.
type MsgSellBackingResponse struct {
	FuryOut   types.Coin `protobuf:"bytes,1,opt,name=fury_out,json=furyOut,proto3" json:"fury_out" yaml:"fury_out"`
	RebackFee types.Coin `protobuf:"bytes,2,opt,name=reback_fee,json=rebackFee,proto3" json:"reback_fee" yaml:"reback_fee"`
}

func (m *MsgSellBackingResponse) Reset()         { *m = MsgSellBackingResponse{} }
func (m *MsgSellBackingResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSellBackingResponse) ProtoMessage()    {}
func (*MsgSellBackingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{7}
}
func (m *MsgSellBackingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSellBackingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSellBackingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSellBackingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSellBackingResponse.Merge(m, src)
}
func (m *MsgSellBackingResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSellBackingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSellBackingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSellBackingResponse proto.InternalMessageInfo

func (m *MsgSellBackingResponse) GetFuryOut() types.Coin {
	if m != nil {
		return m.FuryOut
	}
	return types.Coin{}
}

func (m *MsgSellBackingResponse) GetRebackFee() types.Coin {
	if m != nil {
		return m.RebackFee
	}
	return types.Coin{}
}

// MsgMintByCollateral represents a message to mint Black stablecoins by locking
// collateral.
type MsgMintByCollateral struct {
	Sender          string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender" yaml:"sender"`
	To              string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to" yaml:"to"`
	CollateralDenom string     `protobuf:"bytes,3,opt,name=collateral_denom,json=collateralDenom,proto3" json:"collateral_denom" yaml:"collateral_denom"`
	MintOut         types.Coin `protobuf:"bytes,4,opt,name=mint_out,json=mintOut,proto3" json:"mint_out" yaml:"mint_out"`
}

func (m *MsgMintByCollateral) Reset()         { *m = MsgMintByCollateral{} }
func (m *MsgMintByCollateral) String() string { return proto.CompactTextString(m) }
func (*MsgMintByCollateral) ProtoMessage()    {}
func (*MsgMintByCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{8}
}
func (m *MsgMintByCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintByCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintByCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintByCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintByCollateral.Merge(m, src)
}
func (m *MsgMintByCollateral) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintByCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintByCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintByCollateral proto.InternalMessageInfo

// MsgMintByCollateralResponse defines the Msg/MintByCollateral response type.
type MsgMintByCollateralResponse struct {
	MintFee types.Coin `protobuf:"bytes,1,opt,name=mint_fee,json=mintFee,proto3" json:"mint_fee" yaml:"mint_fee"`
}

func (m *MsgMintByCollateralResponse) Reset()         { *m = MsgMintByCollateralResponse{} }
func (m *MsgMintByCollateralResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMintByCollateralResponse) ProtoMessage()    {}
func (*MsgMintByCollateralResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{9}
}
func (m *MsgMintByCollateralResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintByCollateralResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintByCollateralResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintByCollateralResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintByCollateralResponse.Merge(m, src)
}
func (m *MsgMintByCollateralResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintByCollateralResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintByCollateralResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintByCollateralResponse proto.InternalMessageInfo

func (m *MsgMintByCollateralResponse) GetMintFee() types.Coin {
	if m != nil {
		return m.MintFee
	}
	return types.Coin{}
}

// MsgBurnByCollateral represents a message to burn Black stablecoins by unlocking
// collateral.
type MsgBurnByCollateral struct {
	Sender          string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender" yaml:"sender"`
	CollateralDenom string     `protobuf:"bytes,2,opt,name=collateral_denom,json=collateralDenom,proto3" json:"collateral_denom" yaml:"collateral_denom"`
	RepayInMax      types.Coin `protobuf:"bytes,3,opt,name=repay_in_max,json=repayInMax,proto3" json:"repay_in_max" yaml:"repay_in_max"`
}

func (m *MsgBurnByCollateral) Reset()         { *m = MsgBurnByCollateral{} }
func (m *MsgBurnByCollateral) String() string { return proto.CompactTextString(m) }
func (*MsgBurnByCollateral) ProtoMessage()    {}
func (*MsgBurnByCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{10}
}
func (m *MsgBurnByCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnByCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnByCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnByCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnByCollateral.Merge(m, src)
}
func (m *MsgBurnByCollateral) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnByCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnByCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnByCollateral proto.InternalMessageInfo

// MsgBurnByCollateralResponse defines the Msg/BurnByCollateral response type.
type MsgBurnByCollateralResponse struct {
	RepayIn types.Coin `protobuf:"bytes,1,opt,name=repay_in,json=repayIn,proto3" json:"repay_in" yaml:"repay_in"`
}

func (m *MsgBurnByCollateralResponse) Reset()         { *m = MsgBurnByCollateralResponse{} }
func (m *MsgBurnByCollateralResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnByCollateralResponse) ProtoMessage()    {}
func (*MsgBurnByCollateralResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{11}
}
func (m *MsgBurnByCollateralResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnByCollateralResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnByCollateralResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnByCollateralResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnByCollateralResponse.Merge(m, src)
}
func (m *MsgBurnByCollateralResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnByCollateralResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnByCollateralResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnByCollateralResponse proto.InternalMessageInfo

func (m *MsgBurnByCollateralResponse) GetRepayIn() types.Coin {
	if m != nil {
		return m.RepayIn
	}
	return types.Coin{}
}

// MsgDepositCollateral represents a message to deposit collateral assets.
type MsgDepositCollateral struct {
	Sender       string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender" yaml:"sender"`
	To           string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to" yaml:"to"`
	CollateralIn types.Coin `protobuf:"bytes,3,opt,name=collateral_in,json=collateralIn,proto3" json:"collateral_in" yaml:"collateral_in"`
	FuryIn       types.Coin `protobuf:"bytes,4,opt,name=fury_in,json=furyIn,proto3" json:"fury_in" yaml:"fury_in"`
}

func (m *MsgDepositCollateral) Reset()         { *m = MsgDepositCollateral{} }
func (m *MsgDepositCollateral) String() string { return proto.CompactTextString(m) }
func (*MsgDepositCollateral) ProtoMessage()    {}
func (*MsgDepositCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{12}
}
func (m *MsgDepositCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositCollateral.Merge(m, src)
}
func (m *MsgDepositCollateral) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositCollateral proto.InternalMessageInfo

// MsgDepositCollateralResponse defines the Msg/DepositCollateral response type.
type MsgDepositCollateralResponse struct {
}

func (m *MsgDepositCollateralResponse) Reset()         { *m = MsgDepositCollateralResponse{} }
func (m *MsgDepositCollateralResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDepositCollateralResponse) ProtoMessage()    {}
func (*MsgDepositCollateralResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{13}
}
func (m *MsgDepositCollateralResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositCollateralResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositCollateralResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositCollateralResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositCollateralResponse.Merge(m, src)
}
func (m *MsgDepositCollateralResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositCollateralResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositCollateralResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositCollateralResponse proto.InternalMessageInfo

// MsgRedeemCollateral represents a message to redeem collateral assets and
// collateralized Fury coins.
type MsgRedeemCollateral struct {
	Sender        string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender" yaml:"sender"`
	To            string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to" yaml:"to"`
	CollateralOut types.Coin `protobuf:"bytes,3,opt,name=collateral_out,json=collateralOut,proto3" json:"collateral_out" yaml:"collateral_out"`
	FuryOut       types.Coin `protobuf:"bytes,4,opt,name=fury_out,json=furyOut,proto3" json:"fury_out" yaml:"fury_out"`
}

func (m *MsgRedeemCollateral) Reset()         { *m = MsgRedeemCollateral{} }
func (m *MsgRedeemCollateral) String() string { return proto.CompactTextString(m) }
func (*MsgRedeemCollateral) ProtoMessage()    {}
func (*MsgRedeemCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{14}
}
func (m *MsgRedeemCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRedeemCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRedeemCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRedeemCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRedeemCollateral.Merge(m, src)
}
func (m *MsgRedeemCollateral) XXX_Size() int {
	return m.Size()
}
func (m *MsgRedeemCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRedeemCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRedeemCollateral proto.InternalMessageInfo

// MsgRedeemCollateralResponse defines the Msg/RedeemCollateral response type.
type MsgRedeemCollateralResponse struct {
}

func (m *MsgRedeemCollateralResponse) Reset()         { *m = MsgRedeemCollateralResponse{} }
func (m *MsgRedeemCollateralResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRedeemCollateralResponse) ProtoMessage()    {}
func (*MsgRedeemCollateralResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{15}
}
func (m *MsgRedeemCollateralResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRedeemCollateralResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRedeemCollateralResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRedeemCollateralResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRedeemCollateralResponse.Merge(m, src)
}
func (m *MsgRedeemCollateralResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRedeemCollateralResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRedeemCollateralResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRedeemCollateralResponse proto.InternalMessageInfo

// MsgLiquidateCollateral represents a message to liquidates collateral assets.
type MsgLiquidateCollateral struct {
	Sender     string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender" yaml:"sender"`
	To         string     `protobuf:"bytes,2,opt,name=to,proto3" json:"to" yaml:"to"`
	Debtor     string     `protobuf:"bytes,3,opt,name=debtor,proto3" json:"debtor,omitempty" yaml:"to"`
	Collateral types.Coin `protobuf:"bytes,4,opt,name=collateral,proto3" json:"collateral" yaml:"collateral"`
	RepayInMax types.Coin `protobuf:"bytes,5,opt,name=repay_in_max,json=repayInMax,proto3" json:"repay_in_max" yaml:"repay_in_max"`
}

func (m *MsgLiquidateCollateral) Reset()         { *m = MsgLiquidateCollateral{} }
func (m *MsgLiquidateCollateral) String() string { return proto.CompactTextString(m) }
func (*MsgLiquidateCollateral) ProtoMessage()    {}
func (*MsgLiquidateCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{16}
}
func (m *MsgLiquidateCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLiquidateCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLiquidateCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLiquidateCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLiquidateCollateral.Merge(m, src)
}
func (m *MsgLiquidateCollateral) XXX_Size() int {
	return m.Size()
}
func (m *MsgLiquidateCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLiquidateCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLiquidateCollateral proto.InternalMessageInfo

// MsgLiquidateCollateralResponse defines the Msg/LiquidateCollateral response
// type.
type MsgLiquidateCollateralResponse struct {
	RepayIn       types.Coin `protobuf:"bytes,1,opt,name=repay_in,json=repayIn,proto3" json:"repay_in" yaml:"repay_in"`
	CollateralOut types.Coin `protobuf:"bytes,2,opt,name=collateral_out,json=collateralOut,proto3" json:"collateral_out" yaml:"collateral_out"`
}

func (m *MsgLiquidateCollateralResponse) Reset()         { *m = MsgLiquidateCollateralResponse{} }
func (m *MsgLiquidateCollateralResponse) String() string { return proto.CompactTextString(m) }
func (*MsgLiquidateCollateralResponse) ProtoMessage()    {}
func (*MsgLiquidateCollateralResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d534b23e24b800, []int{17}
}
func (m *MsgLiquidateCollateralResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLiquidateCollateralResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLiquidateCollateralResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLiquidateCollateralResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLiquidateCollateralResponse.Merge(m, src)
}
func (m *MsgLiquidateCollateralResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgLiquidateCollateralResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLiquidateCollateralResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLiquidateCollateralResponse proto.InternalMessageInfo

func (m *MsgLiquidateCollateralResponse) GetRepayIn() types.Coin {
	if m != nil {
		return m.RepayIn
	}
	return types.Coin{}
}

func (m *MsgLiquidateCollateralResponse) GetCollateralOut() types.Coin {
	if m != nil {
		return m.CollateralOut
	}
	return types.Coin{}
}

func init() {
	proto.RegisterType((*MsgMintBySwap)(nil), "blackfury.maker.v1.MsgMintBySwap")
	proto.RegisterType((*MsgMintBySwapResponse)(nil), "blackfury.maker.v1.MsgMintBySwapResponse")
	proto.RegisterType((*MsgBurnBySwap)(nil), "blackfury.maker.v1.MsgBurnBySwap")
	proto.RegisterType((*MsgBurnBySwapResponse)(nil), "blackfury.maker.v1.MsgBurnBySwapResponse")
	proto.RegisterType((*MsgBuyBacking)(nil), "blackfury.maker.v1.MsgBuyBacking")
	proto.RegisterType((*MsgBuyBackingResponse)(nil), "blackfury.maker.v1.MsgBuyBackingResponse")
	proto.RegisterType((*MsgSellBacking)(nil), "blackfury.maker.v1.MsgSellBacking")
	proto.RegisterType((*MsgSellBackingResponse)(nil), "blackfury.maker.v1.MsgSellBackingResponse")
	proto.RegisterType((*MsgMintByCollateral)(nil), "blackfury.maker.v1.MsgMintByCollateral")
	proto.RegisterType((*MsgMintByCollateralResponse)(nil), "blackfury.maker.v1.MsgMintByCollateralResponse")
	proto.RegisterType((*MsgBurnByCollateral)(nil), "blackfury.maker.v1.MsgBurnByCollateral")
	proto.RegisterType((*MsgBurnByCollateralResponse)(nil), "blackfury.maker.v1.MsgBurnByCollateralResponse")
	proto.RegisterType((*MsgDepositCollateral)(nil), "blackfury.maker.v1.MsgDepositCollateral")
	proto.RegisterType((*MsgDepositCollateralResponse)(nil), "blackfury.maker.v1.MsgDepositCollateralResponse")
	proto.RegisterType((*MsgRedeemCollateral)(nil), "blackfury.maker.v1.MsgRedeemCollateral")
	proto.RegisterType((*MsgRedeemCollateralResponse)(nil), "blackfury.maker.v1.MsgRedeemCollateralResponse")
	proto.RegisterType((*MsgLiquidateCollateral)(nil), "blackfury.maker.v1.MsgLiquidateCollateral")
	proto.RegisterType((*MsgLiquidateCollateralResponse)(nil), "blackfury.maker.v1.MsgLiquidateCollateralResponse")
}

func init() { proto.RegisterFile("blackfury/maker/v1/tx.proto", fileDescriptor_30d534b23e24b800) }

var fileDescriptor_30d534b23e24b800 = []byte{
	// 1327 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0x8e, 0x9d, 0x6e, 0xda, 0x4c, 0x7f, 0xae, 0xdb, 0xed, 0x76, 0xd3, 0x6e, 0x52, 0x66, 0x59,
	0xb5, 0xdb, 0x8a, 0x78, 0xdb, 0xde, 0xf6, 0x98, 0x5d, 0x21, 0xb6, 0x22, 0x42, 0x9a, 0x02, 0xaa,
	0x56, 0x88, 0xc8, 0x49, 0x26, 0xc1, 0x6a, 0xe2, 0x09, 0xb6, 0x53, 0x9a, 0x2b, 0x07, 0x40, 0x2b,
	0x21, 0x21, 0x71, 0x87, 0xd5, 0xc2, 0x05, 0xfe, 0x06, 0xee, 0xec, 0xb1, 0xd2, 0x4a, 0x88, 0x53,
	0x84, 0x5a, 0x84, 0x50, 0x8f, 0x3d, 0x73, 0x40, 0x33, 0x1e, 0xdb, 0x63, 0x27, 0xae, 0xd3, 0x4d,
	0xd3, 0x9b, 0x67, 0xfc, 0xde, 0xe7, 0xcf, 0xdf, 0xfb, 0x66, 0xde, 0xd8, 0x60, 0xb9, 0xdc, 0xd0,
	0x2a, 0x07, 0xb5, 0xb6, 0xd9, 0x51, 0x9b, 0xda, 0x01, 0x36, 0xd5, 0xc3, 0x2d, 0xd5, 0x3e, 0xca,
	0xb7, 0x4c, 0x62, 0x13, 0x45, 0xf1, 0x6e, 0xe6, 0xd9, 0xcd, 0xfc, 0xe1, 0x56, 0x66, 0xa5, 0x4e,
	0x48, 0xbd, 0x81, 0x55, 0xad, 0xa5, 0xab, 0x9a, 0x61, 0x10, 0x5b, 0xb3, 0x75, 0x62, 0x58, 0x4e,
	0x46, 0x66, 0xa1, 0x4e, 0xea, 0x84, 0x5d, 0xaa, 0xf4, 0x8a, 0xcf, 0x66, 0x2b, 0xc4, 0x6a, 0x12,
	0x4b, 0x2d, 0x6b, 0x16, 0x56, 0x0f, 0xb7, 0xca, 0xd8, 0xd6, 0xb6, 0xd4, 0x0a, 0xd1, 0x0d, 0xe7,
	0x3e, 0x3c, 0x4e, 0x82, 0xe9, 0xa2, 0x55, 0x2f, 0xea, 0x86, 0x5d, 0xe8, 0xec, 0x7d, 0xa1, 0xb5,
	0x94, 0x1d, 0x90, 0xb2, 0xb0, 0x51, 0xc5, 0xe6, 0x92, 0xb4, 0x2a, 0xad, 0xa7, 0x0b, 0xcb, 0x67,
	0xdd, 0x1c, 0x9f, 0x39, 0xef, 0xe6, 0xa6, 0x3b, 0x5a, 0xb3, 0xf1, 0x08, 0x3a, 0x63, 0x88, 0xf8,
	0x0d, 0xe5, 0x1e, 0x90, 0x6d, 0xb2, 0x24, 0xb3, 0x84, 0xf9, 0xb3, 0x6e, 0x4e, 0xb6, 0xc9, 0x79,
	0x37, 0x97, 0x76, 0x82, 0x6d, 0x02, 0x91, 0x6c, 0x13, 0xe5, 0x53, 0x30, 0x53, 0xd6, 0x2a, 0x07,
	0xba, 0x51, 0x2f, 0xe9, 0x46, 0xa9, 0xa9, 0x1d, 0x2d, 0x25, 0x57, 0xa5, 0xf5, 0xc9, 0xed, 0x3b,
	0x79, 0x87, 0x64, 0x9e, 0x92, 0xcc, 0x73, 0x92, 0xf9, 0xc7, 0x44, 0x37, 0x0a, 0x77, 0x5f, 0x75,
	0x73, 0x89, 0xf3, 0x6e, 0xee, 0x96, 0x83, 0x14, 0x4c, 0x87, 0x68, 0x8a, 0x4f, 0x3c, 0x35, 0x8a,
	0xda, 0x91, 0xf2, 0x11, 0x98, 0xa4, 0x82, 0xb9, 0xe0, 0x63, 0x71, 0xe0, 0x19, 0x0e, 0xae, 0x38,
	0xe0, 0x42, 0x2e, 0x44, 0x69, 0x3a, 0x72, 0x60, 0xf7, 0xc1, 0x54, 0x53, 0x37, 0xec, 0x12, 0x69,
	0xdb, 0xa5, 0xa6, 0x6e, 0x2c, 0xdd, 0x88, 0xc3, 0x5d, 0xe6, 0xb8, 0xf3, 0x0e, 0xae, 0x98, 0x0c,
	0x11, 0xa0, 0xc3, 0x0f, 0xda, 0x76, 0x51, 0x37, 0x94, 0x5d, 0x30, 0x55, 0x6b, 0x37, 0x1a, 0x25,
	0xfe, 0x16, 0x4b, 0xa9, 0x55, 0x69, 0x7d, 0xa2, 0xb0, 0x76, 0xd6, 0xcd, 0x05, 0xe6, 0x7d, 0x28,
	0x71, 0x16, 0xa2, 0x49, 0x3a, 0x2c, 0x38, 0xa3, 0x47, 0x13, 0xdf, 0xbc, 0xc8, 0x25, 0xfe, 0x7d,
	0x91, 0x4b, 0xc0, 0x3f, 0x64, 0x70, 0x2b, 0x50, 0x52, 0x84, 0xad, 0x16, 0x31, 0x2c, 0xac, 0xec,
	0x01, 0xe0, 0x2b, 0xc8, 0xca, 0x7b, 0xe1, 0x7b, 0xdc, 0xe1, 0xef, 0x71, 0x33, 0x2c, 0x3e, 0x44,
	0x69, 0x4f, 0x78, 0x65, 0x17, 0x8c, 0x73, 0xe5, 0x58, 0xfd, 0x2f, 0x44, 0x5c, 0xe4, 0x88, 0x33,
	0x01, 0xc5, 0x21, 0x4a, 0x39, 0x6a, 0x2b, 0x45, 0x30, 0xe1, 0xaa, 0x15, 0xef, 0x8d, 0xdb, 0x1c,
	0x6c, 0x36, 0x28, 0x33, 0x44, 0xe3, 0x5c, 0x62, 0x0f, 0xae, 0x86, 0x71, 0xbc, 0x1b, 0xfa, 0xc1,
	0xd5, 0x30, 0xe6, 0x70, 0xef, 0x62, 0x0c, 0xff, 0x93, 0xd9, 0x5a, 0x29, 0xb4, 0x4d, 0x63, 0xe4,
	0x6b, 0x65, 0x17, 0x8c, 0x97, 0xdb, 0xa6, 0x41, 0x55, 0x4d, 0x5e, 0x52, 0x55, 0x9e, 0x07, 0x51,
	0x8a, 0x5e, 0x3d, 0x35, 0x14, 0x0d, 0xcc, 0xba, 0xb5, 0x73, 0x3d, 0x1c, 0xab, 0x46, 0x96, 0x63,
	0x2e, 0x06, 0x6b, 0xef, 0xd9, 0x78, 0x9a, 0xcf, 0x70, 0x27, 0xef, 0x53, 0x27, 0x9b, 0x9d, 0x37,
	0x5e, 0x23, 0x62, 0x32, 0x44, 0x80, 0x0e, 0x1d, 0x64, 0xc1, 0xd7, 0xdf, 0x3a, 0xbe, 0xf6, 0xe5,
	0xf7, 0x7c, 0xfd, 0x31, 0x98, 0x14, 0x08, 0xc6, 0x1b, 0x3b, 0xb4, 0xf0, 0x85, 0x5c, 0x88, 0x80,
	0xff, 0x62, 0xd4, 0x3f, 0x2e, 0xb1, 0x78, 0x6f, 0x87, 0xfc, 0xe3, 0x26, 0x42, 0x34, 0xce, 0xdf,
	0x86, 0xc2, 0xb1, 0xda, 0x50, 0x3b, 0x5e, 0xd6, 0xdd, 0x6e, 0x22, 0x44, 0xcc, 0x17, 0xd4, 0x8e,
	0x2f, 0x5d, 0x3b, 0x76, 0xf8, 0x1e, 0x30, 0x5a, 0x3b, 0xba, 0x8b, 0x3c, 0x39, 0xec, 0x22, 0x1f,
	0xbd, 0x1d, 0x05, 0xd3, 0xfc, 0x2e, 0x71, 0xd3, 0xb8, 0x22, 0x8d, 0xdc, 0x34, 0x14, 0xb7, 0xdd,
	0xa1, 0x13, 0xac, 0xd0, 0xf2, 0x65, 0x71, 0xfd, 0x5c, 0x8a, 0xeb, 0x8c, 0x68, 0xb9, 0x7f, 0x92,
	0xc1, 0x4c, 0xd1, 0xaa, 0xef, 0x61, 0x6f, 0xcf, 0x1f, 0x61, 0xbd, 0x83, 0x9d, 0x22, 0x79, 0x35,
	0x9d, 0x22, 0xbc, 0x49, 0x8c, 0x8d, 0x60, 0x93, 0xf8, 0x4d, 0x02, 0x8b, 0x41, 0x95, 0xbc, 0x82,
	0x8b, 0xab, 0x59, 0x1a, 0x7e, 0x35, 0xef, 0x01, 0x60, 0xe2, 0xc1, 0xcb, 0x1c, 0x92, 0xc8, 0x4f,
	0x85, 0x28, 0xed, 0x0c, 0x68, 0x91, 0x7f, 0x96, 0xc1, 0xbc, 0xd7, 0xbb, 0x1f, 0x93, 0x46, 0x43,
	0xb3, 0xb1, 0xa9, 0x35, 0x46, 0x58, 0xe9, 0x67, 0x60, 0xae, 0xe2, 0x3d, 0xa7, 0x54, 0xc5, 0x06,
	0x69, 0xb2, 0x7a, 0xa7, 0x0b, 0xea, 0x59, 0x37, 0xd7, 0x73, 0xef, 0xbc, 0x9b, 0xbb, 0xed, 0x00,
	0x84, 0xef, 0x40, 0x34, 0xeb, 0x4f, 0x3d, 0xa1, 0x33, 0x81, 0x76, 0x3e, 0x36, 0x74, 0x3b, 0x17,
	0xaa, 0xdc, 0x00, 0xcb, 0x7d, 0x54, 0x12, 0x2b, 0xed, 0xf5, 0x7d, 0x69, 0xf8, 0xbe, 0xff, 0xdc,
	0x29, 0x8a, 0xd3, 0x78, 0x86, 0x2d, 0x4a, 0x3f, 0xbd, 0xe5, 0x2b, 0xd2, 0x7b, 0x1f, 0x4c, 0x99,
	0xb8, 0xa5, 0x75, 0x06, 0x3e, 0x5e, 0x87, 0x16, 0x98, 0x98, 0x0c, 0x11, 0x60, 0x43, 0x76, 0x06,
	0xee, 0x91, 0x3e, 0xac, 0x85, 0x28, 0xbd, 0x8b, 0x72, 0x69, 0xe9, 0xdd, 0x44, 0x88, 0xc6, 0xf9,
	0xa3, 0xe9, 0x7a, 0x58, 0x28, 0x5a, 0xf5, 0x27, 0xb8, 0x45, 0x2c, 0xdd, 0xbe, 0x96, 0x05, 0xf1,
	0x09, 0x98, 0x16, 0xa4, 0x1e, 0x64, 0xf7, 0x5b, 0xe1, 0xaf, 0xb1, 0xd0, 0x53, 0x28, 0xfa, 0x2e,
	0x53, 0xfe, 0x38, 0x78, 0x5a, 0x1e, 0x1b, 0xb2, 0x91, 0x0a, 0x45, 0xc9, 0x82, 0x95, 0x7e, 0x2a,
	0xb9, 0x55, 0x81, 0xbf, 0x38, 0x0e, 0x46, 0xb8, 0x8a, 0x71, 0xf3, 0x5a, 0x54, 0x2c, 0x81, 0x19,
	0x41, 0x87, 0x81, 0xce, 0xf3, 0xa1, 0x6f, 0xbd, 0x60, 0x3a, 0x44, 0x42, 0x55, 0xc2, 0x67, 0xb3,
	0xb1, 0xa1, 0x77, 0x73, 0x41, 0xcb, 0xbb, 0xcc, 0xe0, 0x61, 0xa9, 0x3c, 0x29, 0x5f, 0xcb, 0xac,
	0xc1, 0xbc, 0xaf, 0x7f, 0xde, 0xd6, 0xab, 0x9a, 0x8d, 0xaf, 0x45, 0xcd, 0xfb, 0x20, 0x55, 0xc5,
	0x65, 0x9b, 0x98, 0x7c, 0x6b, 0x9e, 0x0e, 0x86, 0xf0, 0x9b, 0xca, 0x87, 0x00, 0xf8, 0x22, 0xc5,
	0xab, 0x12, 0x6a, 0x49, 0x7e, 0x2a, 0x44, 0x02, 0x4e, 0xcf, 0xae, 0x72, 0x63, 0x04, 0xbb, 0xca,
	0xb1, 0x04, 0xb2, 0xfd, 0x55, 0x1d, 0xd1, 0xce, 0xd2, 0xc7, 0xa0, 0xf2, 0x95, 0x1a, 0x74, 0xfb,
	0x1f, 0x00, 0x92, 0x45, 0xab, 0xae, 0x7c, 0x2d, 0x01, 0x20, 0xfc, 0x5e, 0x79, 0x2b, 0xdf, 0xfb,
	0x67, 0x27, 0x1f, 0xf8, 0x5c, 0xcf, 0x3c, 0x88, 0x0d, 0xf1, 0xdc, 0xb8, 0xf9, 0xe5, 0xeb, 0xbf,
	0xbf, 0x97, 0xef, 0x2b, 0xf7, 0xd4, 0xbe, 0x3f, 0x93, 0x54, 0xd6, 0xcd, 0xca, 0x9d, 0x92, 0x45,
	0x1f, 0x4d, 0x99, 0x08, 0x1f, 0xaf, 0x51, 0x4c, 0xfc, 0x90, 0x48, 0x26, 0xbd, 0xdf, 0x60, 0xb1,
	0x4c, 0xd8, 0x07, 0x8c, 0xcb, 0xe4, 0x2b, 0xc6, 0xc4, 0xfb, 0x6e, 0x89, 0x66, 0xe2, 0x86, 0x5c,
	0xc0, 0x24, 0x7c, 0xb0, 0x87, 0x1b, 0x8c, 0xc9, 0xdb, 0x0a, 0x8c, 0x64, 0xd2, 0x71, 0xff, 0xa1,
	0x28, 0xcf, 0x25, 0x30, 0x29, 0x9e, 0xa8, 0x61, 0xc4, 0x63, 0x84, 0x98, 0xcc, 0x46, 0x7c, 0xcc,
	0xc0, 0xaa, 0x58, 0xd8, 0xff, 0xa1, 0xa3, 0xfc, 0x28, 0x81, 0xb9, 0x9e, 0x93, 0xdf, 0xda, 0x85,
	0x66, 0xf0, 0x03, 0x33, 0xea, 0x80, 0x81, 0x1e, 0xb7, 0x2d, 0xc6, 0x6d, 0x53, 0x79, 0x10, 0xe3,
	0x1d, 0x61, 0x2b, 0xa0, 0x0c, 0x7b, 0x8e, 0x41, 0x6b, 0x17, 0x9a, 0x64, 0x00, 0x86, 0x51, 0x87,
	0x89, 0x58, 0x86, 0xae, 0xa7, 0x04, 0x86, 0x2f, 0x25, 0x70, 0xb3, 0xf7, 0xb4, 0xb0, 0x1e, 0xf1,
	0xe4, 0x9e, 0xc8, 0xcc, 0xc3, 0x41, 0x23, 0x07, 0x26, 0x59, 0x75, 0x32, 0x45, 0x92, 0x3f, 0x48,
	0x60, 0xae, 0xa7, 0x17, 0x47, 0xc9, 0x18, 0x0e, 0x8c, 0x94, 0x31, 0xb2, 0x65, 0x3d, 0x64, 0x0c,
	0x37, 0x94, 0xf5, 0x08, 0x86, 0x26, 0x4b, 0x14, 0x09, 0xfe, 0x2a, 0x81, 0xf9, 0x7e, 0x1d, 0x2e,
	0xca, 0xfa, 0x7d, 0x62, 0x33, 0xdb, 0x83, 0xc7, 0x7a, 0x4c, 0x77, 0x18, 0xd3, 0x77, 0x94, 0xcd,
	0x08, 0xa6, 0x0d, 0x37, 0x57, 0x20, 0x5b, 0x78, 0xef, 0xd5, 0x49, 0x56, 0x3a, 0x3e, 0xc9, 0x4a,
	0x7f, 0x9d, 0x64, 0xa5, 0xef, 0x4e, 0xb3, 0x89, 0xe3, 0xd3, 0x6c, 0xe2, 0xcf, 0xd3, 0x6c, 0xe2,
	0x59, 0xbe, 0xae, 0xdb, 0x9f, 0xb5, 0xcb, 0xf9, 0x0a, 0x69, 0xaa, 0xa4, 0x56, 0xb3, 0xf4, 0x2a,
	0xa6, 0xdb, 0x8f, 0x00, 0x7e, 0xc4, 0xe1, 0xed, 0x4e, 0x0b, 0x5b, 0xe5, 0x14, 0xfb, 0x27, 0xbe,
	0xf3, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xab, 0x22, 0x6a, 0xf7, 0x9a, 0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// MintBySwap mints Black stablecoins by swapping in strong-backing assets and
	// Fury coins.
	MintBySwap(ctx context.Context, in *MsgMintBySwap, opts ...grpc.CallOption) (*MsgMintBySwapResponse, error)
	// BurnBySwap burns Black stablecoins by swapping out strong-backing assets and
	// Fury coins.
	BurnBySwap(ctx context.Context, in *MsgBurnBySwap, opts ...grpc.CallOption) (*MsgBurnBySwapResponse, error)
	// BuyBacking buys strong-backing assets by spending Fury coins.
	BuyBacking(ctx context.Context, in *MsgBuyBacking, opts ...grpc.CallOption) (*MsgBuyBackingResponse, error)
	// SellBacking sells strong-backing assets by earning Fury
	// coins.
	SellBacking(ctx context.Context, in *MsgSellBacking, opts ...grpc.CallOption) (*MsgSellBackingResponse, error)
	// MintByCollateral mints Black stablecoins by locking collateral assets and
	// spending Fury coins.
	MintByCollateral(ctx context.Context, in *MsgMintByCollateral, opts ...grpc.CallOption) (*MsgMintByCollateralResponse, error)
	// BurnByCollateral burns Black stablecoins by unlocking collateral assets and
	// earning Fury coins.
	BurnByCollateral(ctx context.Context, in *MsgBurnByCollateral, opts ...grpc.CallOption) (*MsgBurnByCollateralResponse, error)
	// DepositCollateral deposits collateral assets.
	DepositCollateral(ctx context.Context, in *MsgDepositCollateral, opts ...grpc.CallOption) (*MsgDepositCollateralResponse, error)
	// RedeemCollateral redeems collateral assets and collateralized Fury coins.
	RedeemCollateral(ctx context.Context, in *MsgRedeemCollateral, opts ...grpc.CallOption) (*MsgRedeemCollateralResponse, error)
	// LiquidateCollateral liquidates collateral assets which is
	// undercollateralized.
	LiquidateCollateral(ctx context.Context, in *MsgLiquidateCollateral, opts ...grpc.CallOption) (*MsgLiquidateCollateralResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) MintBySwap(ctx context.Context, in *MsgMintBySwap, opts ...grpc.CallOption) (*MsgMintBySwapResponse, error) {
	out := new(MsgMintBySwapResponse)
	err := c.cc.Invoke(ctx, "/blackfury.maker.v1.Msg/MintBySwap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnBySwap(ctx context.Context, in *MsgBurnBySwap, opts ...grpc.CallOption) (*MsgBurnBySwapResponse, error) {
	out := new(MsgBurnBySwapResponse)
	err := c.cc.Invoke(ctx, "/blackfury.maker.v1.Msg/BurnBySwap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BuyBacking(ctx context.Context, in *MsgBuyBacking, opts ...grpc.CallOption) (*MsgBuyBackingResponse, error) {
	out := new(MsgBuyBackingResponse)
	err := c.cc.Invoke(ctx, "/blackfury.maker.v1.Msg/BuyBacking", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SellBacking(ctx context.Context, in *MsgSellBacking, opts ...grpc.CallOption) (*MsgSellBackingResponse, error) {
	out := new(MsgSellBackingResponse)
	err := c.cc.Invoke(ctx, "/blackfury.maker.v1.Msg/SellBacking", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintByCollateral(ctx context.Context, in *MsgMintByCollateral, opts ...grpc.CallOption) (*MsgMintByCollateralResponse, error) {
	out := new(MsgMintByCollateralResponse)
	err := c.cc.Invoke(ctx, "/blackfury.maker.v1.Msg/MintByCollateral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnByCollateral(ctx context.Context, in *MsgBurnByCollateral, opts ...grpc.CallOption) (*MsgBurnByCollateralResponse, error) {
	out := new(MsgBurnByCollateralResponse)
	err := c.cc.Invoke(ctx, "/blackfury.maker.v1.Msg/BurnByCollateral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DepositCollateral(ctx context.Context, in *MsgDepositCollateral, opts ...grpc.CallOption) (*MsgDepositCollateralResponse, error) {
	out := new(MsgDepositCollateralResponse)
	err := c.cc.Invoke(ctx, "/blackfury.maker.v1.Msg/DepositCollateral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RedeemCollateral(ctx context.Context, in *MsgRedeemCollateral, opts ...grpc.CallOption) (*MsgRedeemCollateralResponse, error) {
	out := new(MsgRedeemCollateralResponse)
	err := c.cc.Invoke(ctx, "/blackfury.maker.v1.Msg/RedeemCollateral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) LiquidateCollateral(ctx context.Context, in *MsgLiquidateCollateral, opts ...grpc.CallOption) (*MsgLiquidateCollateralResponse, error) {
	out := new(MsgLiquidateCollateralResponse)
	err := c.cc.Invoke(ctx, "/blackfury.maker.v1.Msg/LiquidateCollateral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// MintBySwap mints Black stablecoins by swapping in strong-backing assets and
	// Fury coins.
	MintBySwap(context.Context, *MsgMintBySwap) (*MsgMintBySwapResponse, error)
	// BurnBySwap burns Black stablecoins by swapping out strong-backing assets and
	// Fury coins.
	BurnBySwap(context.Context, *MsgBurnBySwap) (*MsgBurnBySwapResponse, error)
	// BuyBacking buys strong-backing assets by spending Fury coins.
	BuyBacking(context.Context, *MsgBuyBacking) (*MsgBuyBackingResponse, error)
	// SellBacking sells strong-backing assets by earning Fury
	// coins.
	SellBacking(context.Context, *MsgSellBacking) (*MsgSellBackingResponse, error)
	// MintByCollateral mints Black stablecoins by locking collateral assets and
	// spending Fury coins.
	MintByCollateral(context.Context, *MsgMintByCollateral) (*MsgMintByCollateralResponse, error)
	// BurnByCollateral burns Black stablecoins by unlocking collateral assets and
	// earning Fury coins.
	BurnByCollateral(context.Context, *MsgBurnByCollateral) (*MsgBurnByCollateralResponse, error)
	// DepositCollateral deposits collateral assets.
	DepositCollateral(context.Context, *MsgDepositCollateral) (*MsgDepositCollateralResponse, error)
	// RedeemCollateral redeems collateral assets and collateralized Fury coins.
	RedeemCollateral(context.Context, *MsgRedeemCollateral) (*MsgRedeemCollateralResponse, error)
	// LiquidateCollateral liquidates collateral assets which is
	// undercollateralized.
	LiquidateCollateral(context.Context, *MsgLiquidateCollateral) (*MsgLiquidateCollateralResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) MintBySwap(ctx context.Context, req *MsgMintBySwap) (*MsgMintBySwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintBySwap not implemented")
}
func (*UnimplementedMsgServer) BurnBySwap(ctx context.Context, req *MsgBurnBySwap) (*MsgBurnBySwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnBySwap not implemented")
}
func (*UnimplementedMsgServer) BuyBacking(ctx context.Context, req *MsgBuyBacking) (*MsgBuyBackingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuyBacking not implemented")
}
func (*UnimplementedMsgServer) SellBacking(ctx context.Context, req *MsgSellBacking) (*MsgSellBackingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SellBacking not implemented")
}
func (*UnimplementedMsgServer) MintByCollateral(ctx context.Context, req *MsgMintByCollateral) (*MsgMintByCollateralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintByCollateral not implemented")
}
func (*UnimplementedMsgServer) BurnByCollateral(ctx context.Context, req *MsgBurnByCollateral) (*MsgBurnByCollateralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnByCollateral not implemented")
}
func (*UnimplementedMsgServer) DepositCollateral(ctx context.Context, req *MsgDepositCollateral) (*MsgDepositCollateralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositCollateral not implemented")
}
func (*UnimplementedMsgServer) RedeemCollateral(ctx context.Context, req *MsgRedeemCollateral) (*MsgRedeemCollateralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedeemCollateral not implemented")
}
func (*UnimplementedMsgServer) LiquidateCollateral(ctx context.Context, req *MsgLiquidateCollateral) (*MsgLiquidateCollateralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LiquidateCollateral not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_MintBySwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintBySwap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintBySwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blackfury.maker.v1.Msg/MintBySwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintBySwap(ctx, req.(*MsgMintBySwap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnBySwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnBySwap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnBySwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blackfury.maker.v1.Msg/BurnBySwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnBySwap(ctx, req.(*MsgBurnBySwap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BuyBacking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBuyBacking)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BuyBacking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blackfury.maker.v1.Msg/BuyBacking",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BuyBacking(ctx, req.(*MsgBuyBacking))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SellBacking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSellBacking)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SellBacking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blackfury.maker.v1.Msg/SellBacking",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SellBacking(ctx, req.(*MsgSellBacking))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintByCollateral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintByCollateral)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintByCollateral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blackfury.maker.v1.Msg/MintByCollateral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintByCollateral(ctx, req.(*MsgMintByCollateral))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnByCollateral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnByCollateral)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnByCollateral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blackfury.maker.v1.Msg/BurnByCollateral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnByCollateral(ctx, req.(*MsgBurnByCollateral))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DepositCollateral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDepositCollateral)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DepositCollateral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blackfury.maker.v1.Msg/DepositCollateral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DepositCollateral(ctx, req.(*MsgDepositCollateral))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RedeemCollateral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRedeemCollateral)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RedeemCollateral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blackfury.maker.v1.Msg/RedeemCollateral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RedeemCollateral(ctx, req.(*MsgRedeemCollateral))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_LiquidateCollateral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgLiquidateCollateral)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).LiquidateCollateral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/blackfury.maker.v1.Msg/LiquidateCollateral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).LiquidateCollateral(ctx, req.(*MsgLiquidateCollateral))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "blackfury.maker.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MintBySwap",
			Handler:    _Msg_MintBySwap_Handler,
		},
		{
			MethodName: "BurnBySwap",
			Handler:    _Msg_BurnBySwap_Handler,
		},
		{
			MethodName: "BuyBacking",
			Handler:    _Msg_BuyBacking_Handler,
		},
		{
			MethodName: "SellBacking",
			Handler:    _Msg_SellBacking_Handler,
		},
		{
			MethodName: "MintByCollateral",
			Handler:    _Msg_MintByCollateral_Handler,
		},
		{
			MethodName: "BurnByCollateral",
			Handler:    _Msg_BurnByCollateral_Handler,
		},
		{
			MethodName: "DepositCollateral",
			Handler:    _Msg_DepositCollateral_Handler,
		},
		{
			MethodName: "RedeemCollateral",
			Handler:    _Msg_RedeemCollateral_Handler,
		},
		{
			MethodName: "LiquidateCollateral",
			Handler:    _Msg_LiquidateCollateral_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "blackfury/maker/v1/tx.proto",
}

func (m *MsgMintBySwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintBySwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintBySwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FullBacking {
		i--
		if m.FullBacking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.MintOutMin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.FuryInMax.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.BackingInMax.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintBySwapResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintBySwapResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintBySwapResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MintFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.MintOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.FuryIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.BackingIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgBurnBySwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnBySwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnBySwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FuryOutMin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.BackingOutMin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.BurnIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnBySwapResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnBySwapResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnBySwapResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.BurnFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.FuryOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.BackingOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgBuyBacking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBuyBacking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBuyBacking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.BackingOutMin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.FuryIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBuyBackingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBuyBackingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBuyBackingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.BuybackFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.BackingOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSellBacking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSellBacking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSellBacking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FuryOutMin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.BackingIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSellBackingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSellBackingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSellBackingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RebackFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.FuryOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgMintByCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintByCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintByCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MintOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.CollateralDenom) > 0 {
		i -= len(m.CollateralDenom)
		copy(dAtA[i:], m.CollateralDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CollateralDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintByCollateralResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintByCollateralResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintByCollateralResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MintFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgBurnByCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnByCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnByCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RepayInMax.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.CollateralDenom) > 0 {
		i -= len(m.CollateralDenom)
		copy(dAtA[i:], m.CollateralDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CollateralDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnByCollateralResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnByCollateralResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnByCollateralResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RepayIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgDepositCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FuryIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.CollateralIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositCollateralResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositCollateralResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositCollateralResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRedeemCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRedeemCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRedeemCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FuryOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.CollateralOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRedeemCollateralResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRedeemCollateralResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRedeemCollateralResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgLiquidateCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLiquidateCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLiquidateCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RepayInMax.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Debtor) > 0 {
		i -= len(m.Debtor)
		copy(dAtA[i:], m.Debtor)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Debtor)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgLiquidateCollateralResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLiquidateCollateralResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLiquidateCollateralResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.CollateralOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RepayIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgMintBySwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.BackingInMax.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.FuryInMax.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MintOutMin.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.FullBacking {
		n += 2
	}
	return n
}

func (m *MsgMintBySwapResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BackingIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.FuryIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MintOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MintFee.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBurnBySwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.BurnIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.BackingOutMin.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.FuryOutMin.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBurnBySwapResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BackingOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.FuryOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.BurnFee.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBuyBacking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.FuryIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.BackingOutMin.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBuyBackingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BackingOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.BuybackFee.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSellBacking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.BackingIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.FuryOutMin.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSellBackingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FuryOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.RebackFee.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgMintByCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CollateralDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MintOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgMintByCollateralResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MintFee.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBurnByCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CollateralDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.RepayInMax.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBurnByCollateralResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RepayIn.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDepositCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollateralIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.FuryIn.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDepositCollateralResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRedeemCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollateralOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.FuryOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRedeemCollateralResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgLiquidateCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Debtor)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Collateral.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.RepayInMax.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgLiquidateCollateralResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RepayIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.CollateralOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgMintBySwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintBySwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintBySwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingInMax", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingInMax.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryInMax", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryInMax.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintOutMin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintOutMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullBacking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FullBacking = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintBySwapResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintBySwapResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintBySwapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnBySwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnBySwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnBySwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingOutMin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingOutMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryOutMin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryOutMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnBySwapResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnBySwapResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnBySwapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBuyBacking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBuyBacking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBuyBacking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingOutMin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingOutMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBuyBackingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBuyBackingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBuyBackingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuybackFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BuybackFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSellBacking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSellBacking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSellBacking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryOutMin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryOutMin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSellBackingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSellBackingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSellBackingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebackFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RebackFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintByCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintByCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintByCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintByCollateralResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintByCollateralResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintByCollateralResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnByCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnByCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnByCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepayInMax", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepayInMax.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnByCollateralResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnByCollateralResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnByCollateralResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepayIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepayIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositCollateralResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositCollateralResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositCollateralResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRedeemCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRedeemCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRedeemCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuryOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FuryOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRedeemCollateralResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRedeemCollateralResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRedeemCollateralResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLiquidateCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLiquidateCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLiquidateCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debtor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Debtor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepayInMax", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepayInMax.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLiquidateCollateralResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLiquidateCollateralResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLiquidateCollateralResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepayIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepayIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
